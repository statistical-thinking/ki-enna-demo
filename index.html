<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>KI-ENNA Netzwerk-Editor</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    pre { background: #f4f4f4; padding: 10px; }
    .layer-config { margin-left: 20px; margin-bottom: 15px; border-left: 2px solid #ccc; padding-left: 10px; }
    label { display: block; margin-bottom: 5px; }
    #networkViz svg { border: 1px solid #aaa; margin-top: 20px; }
  </style>
</head>
<body>

<h2>üìÅ Schritt 1: CSV-Datensatz einlesen</h2>
<input type="file" id="csvInput" accept=".csv">
<button onclick="handleCSV()">CSV laden</button>

<pre id="output">Noch keine CSV geladen.</pre>

<hr>

<h2>üîß Schritte 2‚Äì5: Netzwerk konfigurieren & anzeigen</h2>

<label for="layerCount">Anzahl Hidden-Layer:</label>
<input type="range" id="layerCount" min="1" max="5" value="2" oninput="updateLayerControls()">
<span id="layerCountVal">2</span>

<div id="layersContainer"></div>

<label for="epochs">Epochen:</label>
<input type="number" id="epochs" value="100" min="10" max="1000" oninput="updateArchitecture()">

<label for="lr">Lernrate:</label>
<input type="number" id="lr" value="0.01" step="0.001" min="0.001" max="1.0" oninput="updateArchitecture()">

<pre id="archOutput">Netzwerkarchitektur wird hier angezeigt.</pre>

<div id="networkViz"></div>

<button onclick="trainNetwork()">üß† Netzwerk trainieren</button>
<pre id="trainOutput">Noch kein Training durchgef√ºhrt.</pre>

<script>
let pyodideReady = loadPyodide();

async function handleCSV() {
  const fileInput = document.getElementById("csvInput");
  const file = fileInput.files[0];
  if (!file) {
    alert("Bitte eine CSV-Datei ausw√§hlen.");
    return;
  }

  const reader = new FileReader();
  reader.onload = async () => {
    const csvData = reader.result;
    const pyodide = await pyodideReady;

    pyodide.FS.writeFile("data.csv", new TextEncoder().encode(csvData));

    await pyodide.loadPackage("pandas");
    const result = await pyodide.runPythonAsync(`
import pandas as pd
df = pd.read_csv("data.csv")
df.head().to_string()
    `);
    document.getElementById("output").textContent = result;
  };

  reader.readAsText(file);
}

function updateLayerControls() {
  const count = parseInt(document.getElementById("layerCount").value);
  document.getElementById("layerCountVal").textContent = count;
  const container = document.getElementById("layersContainer");
  container.innerHTML = "";

  for (let i = 0; i < count; i++) {
    const div = document.createElement("div");
    div.className = "layer-config";
    div.innerHTML = `
      <label>Layer ${i + 1}: Neuronenanzahl
        <input type="range" min="1" max="20" value="4" id="neurons_${i}" oninput="updateArchitecture()">
        <span id="neurons_val_${i}">4</span>
      </label>
      <label>Aktivierungsfunktion:
        <select id="activation_${i}" onchange="updateArchitecture()">
          <option value="sigmoid">Sigmoid</option>
          <option value="relu">ReLU</option>
          <option value="leaky_relu">Leaky ReLU</option>
          <option value="tanh">Tanh</option>
        </select>
      </label>
    `;
    container.appendChild(div);
  }

  updateArchitecture();
}

function updateArchitecture() {
  const count = parseInt(document.getElementById("layerCount").value);
  let architecture = [];
  for (let i = 0; i < count; i++) {
    const neurons = parseInt(document.getElementById(`neurons_${i}`).value);
    document.getElementById(`neurons_val_${i}`).textContent = neurons;
    const activation = document.getElementById(`activation_${i}`).value;
    architecture.push({ layer: i + 1, neurons, activation });
  }

  const epochs = document.getElementById("epochs").value;
  const lr = document.getElementById("lr").value;

  const text = architecture.map(l =>
    `Layer ${l.layer}: ${l.neurons} Neuronen, Aktivierung: ${l.activation}`
  ).join("\n");

  document.getElementById("archOutput").textContent =
    "Aktuelle Netzwerkarchitektur:\n" +
    text + `\n\nEpochen: ${epochs}, Lernrate: ${lr}`;

  drawNetwork();
}

function drawNetwork() {
  const svgNS = "http://www.w3.org/2000/svg";
  const container = document.getElementById("networkViz");
  container.innerHTML = "";
  const width = 600, height = 300;
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", width);
  svg.setAttribute("height", height);

  const inputLayer = { neurons: 4, activation: "Input" };
  const outputLayer = { neurons: 3, activation: "Output" };
  const hidden = [];

  const count = parseInt(document.getElementById("layerCount").value);
  for (let i = 0; i < count; i++) {
    const neurons = parseInt(document.getElementById(`neurons_${i}`).value);
    const activation = document.getElementById(`activation_${i}`).value;
    hidden.push({ neurons, activation });
  }

  const layers = [inputLayer, ...hidden, outputLayer];
  const layerGap = width / (layers.length + 1);
  const neuronRadius = 10;
  const positions = [];

  layers.forEach((layer, i) => {
    const yStep = height / (layer.neurons + 1);
    const layerPos = [];
    for (let j = 0; j < layer.neurons; j++) {
      const cx = (i + 1) * layerGap;
      const cy = (j + 1) * yStep;
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", cx);
      circle.setAttribute("cy", cy);
      circle.setAttribute("r", neuronRadius);
      circle.setAttribute("fill", "#000");
      circle.setAttribute("stroke", "#000");
      svg.appendChild(circle);
      layerPos.push({ x: cx, y: cy });
    }
    positions.push(layerPos);

    const text = document.createElementNS(svgNS, "text");
    text.setAttribute("x", (i + 1) * layerGap);
    text.setAttribute("y", 15);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("font-size", "12px");
    text.textContent = layer.activation;
    svg.appendChild(text);
  });

  for (let i = 0; i < positions.length - 1; i++) {
    for (const from of positions[i]) {
      for (const to of positions[i + 1]) {
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", from.x);
        line.setAttribute("y1", from.y);
        line.setAttribute("x2", to.x);
        line.setAttribute("y2", to.y);
        line.setAttribute("stroke", "#000");
        svg.appendChild(line);
      }
    }
  }

  container.appendChild(svg);
}

async function trainNetwork() {
  const pyodide = await pyodideReady;

  const layerCount = parseInt(document.getElementById("layerCount").value);
  const epochs = parseInt(document.getElementById("epochs").value);
  const lr = parseFloat(document.getElementById("lr").value);

  const architecture = [];
  for (let i = 0; i < layerCount; i++) {
    const neurons = parseInt(document.getElementById(`neurons_${i}`).value);
    const activation = document.getElementById(`activation_${i}`).value;
    architecture.push({ neurons, activation });
  }

  const archJSON = JSON.stringify(architecture);

  const pythonCode = `...`;  // siehe vorheriger Schritt (wird hier nicht komplett eingef√ºgt, siehe Limit)

  const result = await pyodide.runPythonAsync(pythonCode);
  document.getElementById("trainOutput").textContent = result;
}

updateLayerControls();
</script>
</body>
</html>